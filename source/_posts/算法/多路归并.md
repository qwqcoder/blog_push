---
title: 多路归并
categories: 算法学习
tag: 多路归并
abbrlink: d14b420f
data:
---

+ [例题1, 技能升级](https://www.acwing.com/problem/content/4659/)

# 思路

**多路合并 + 二分**

> 多路等差数列:
> 10 5
> 9 7 5 3 1
> 8 7 6 5 4 3 2 1
>
> 从多个数列(这里是等差数列)中, 找到前 `m` 大的数, 求和输出答案
>
> 运用二分, 枚举 `mid`, 并用 `check(int mid)` 函数判断, 具体过程如下, 对于每个等差数列, 根据 `mid` 判断其有多少个项大于 `mid`, 累计数量到 `cnt`, 循环完成 `n` 个等差数列后, 判断 `cnt >= m`,
> 最后使用 `ans` 累计这些前 `m` 大的数的和, 注意这里的等差数列中可能包含多个等于 `mid` 的项, 多出来的数量为 `cnt − m` 个
>
> `ans − (cnt − m) ∗ l` 即是最终答案

😥😥😥, 猪脑过载, 





+ [例题2](https://www.acwing.com/problem/content/description/58/)

# 思路

**多路合并**

> 创建两个队列, 分别存放包含 2, 3, 5这些质因子的数
>
> 一开始, `a` 队列只有 2 一个数, `b` 队列只有 3 一个数, `c` 队列只有 5 一个数
>
> 操作步骤为, 每次从 `a, b, c` 三个队列中取出队头最小的那个数记为 `curr`, 同时将 `curr * 2` 放入 `a` 队列, `curr * 3` 放入 `b` 队列, `curr * 5` 放入 `c` 队列. 这样子每个



+ [例题3](https://www.acwing.com/problem/content/description/1380/)

**多路合并**

**定义**: 丑数是一组质数集合 $S$ 中若干个质数(可重复)的乘积, 

**题意**: 从给定包含 $k$ 个不同质数的集合 $S = \{p_1, p_2,...,p_k\}$ 中找到从小到大的第 $K$ 大的丑数

# 思路

> 一个显然的性质是，任意一个丑数都可以由另一个比他小的丑数乘以一个质数因子得到。
>
> 那么构造一个数组 `f` 用来从小到大更新丑数，`f[0]=1` 特判, 对于下一个丑数的更新, 构造如下:
>
> 对于每一个质因子`a[j]`, 我们用已经构造出的前 `i` 个丑数依次与 `a[j]` 做乘法, 从而构造出一个新的丑数,  对于每个质数 `a[j]`, 分别找到丑数 `a[j] * f[idx]`(满足 `a[j]*f[idx]` 刚好大于 `f[i-1]` 即可), 并找到最小的那个丑数作为 `f[i]`。往后的更新就用不着 `idx` 之前的丑数了，所以用个 `b` 数组记录第 `i` 个质数枚举 `f[i]` 的下标位置

```c++
#include <iostream>
using namespace std;
const int N = 100010;
int k,n;
int a[N],f[N],b[N];
// a 数组用于存放给定的质数集合，f 数组从小到大记录丑数
// b 数组记录第 i 个质因子的枚举位置
int main () {
    cin >> k >> n;
    for (int i = 1;i <= k;i++)  cin >> a[i];
    f[0] = 1;
    for (int i = 1;i <= n;i++) {
        int minx = 2e9;
        for (int j = 1;j <= k;j++) {
            while (a[j]*f[b[j]] <= f[i-1]) b[j]++;
            minx = min (minx,a[j]*f[b[j]]);
        }
        f[i] = minx;
    }
    cout << f[n] << endl;
    return 0;
}
```

